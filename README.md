# crypto_auth

Первым делом, необходимо было создать базовый сервер + базу данных. Сервер мы сделали на Node.js + Fastify. В качестве базы данных мы используем PostgreSQL.

Одним из первых дел, которые необходимо сделать для защиты данных пользователя - настроить ssl (разумеется, речь идёт про tls не ниже версии 1.2, но все привыкли называть это именно ssl).
Поскольку мы не планировали деплоить солюшн на облако, то нам надо было "засертификатить" локалхост, чисто в целях дебага. Сделали мы это с помощью инструмента mkcert.

Затем, добавляем полученные сертификаты в настройки сервера fastify в разделе https.

Для того, чтоб усложнить жизнь взломщику, мы проверяем пароли на предмет "простоты", уточняя, есть ли новый пароль в базе самых часто используемых. Если есть, мы просим его переделать.
В качестве крипто-библиотеки мы используем libsodium. Для того, чтоб, взломав бд и подбирая пароли, злоумышленник дал нам больше времени на ответные меры, мы хэшируем пароли алгоритмом Argon2 (для того, чтоб это не занимало вечность в некоторых случаях, мы также по рекоммендации OWASP ограничиваем ввод до 60 символов). Для того, чтоб повысить защиту пароля, мы шифруем его алгоритмом xsalsa20-poly1305 с помощью централизованно лежащего ключа. Теперь логин юзера выглядит так: пароль приходит к нам, мы проверяем, есть ли такой юзер или нет, достаём его зашифрованный-захэшированный пароль, расшифровываем, и сравниваем его (захэшированный пароль из бд) с хэшем пароля, присланного пользователем.

Для защиты данных пользователя мы используем envelope encryption (разумеется, лучше использовать key management service для повышения секюрности KEK-ов, но это не наш случай). Для каждого юзера генерируется его собственный ключ для шифрования его личных данных (номер кредитной карты, адрес, etc.), который, в свою очередь, шифруется нашим централизованным ключом. В KMS можно создавать дополнительные ключи KEK-и для каждой из групп данных, что повышает защиту данных (в нашем случае один KEK для кучи DEK-ов, лучше было бы много KEK-ов для кучи DEK-ов). При каждом новом вводе данных пользователя, мы ротейтим его ключ, повторно перешифруя все его данные. Безусловно, было бы лучше дополнительно настроить ротацию ключей по какому-то временному интервалу, но это не наш случай.
